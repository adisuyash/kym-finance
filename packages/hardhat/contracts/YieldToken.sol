// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title YieldToken (YT-wU2U)
 * @dev Represents the yield component of yield-bearing wU2U
 * @notice YT tokens entitle holders to claim yield generated by the underlying asset
 */
contract YieldToken is ERC20, ReentrancyGuard, Ownable {
    
    // The underlying asset (wU2U)
    address public immutable underlyingAsset;
    
    // The principal token contract address
    address public principalToken;
    
    // The yield splitter contract (only this can mint/burn)
    address public yieldSplitter;
    
    // Maturity timestamp
    uint256 public immutable maturity;
    
    // Whether the token has expired
    bool public isExpired;
    
    // Yield tracking
    mapping(address => uint256) public lastClaimTime;
    mapping(address => uint256) public accumulatedYield;
    
    // Global yield tracking
    uint256 public totalYieldGenerated;
    uint256 public totalYieldClaimed;
    uint256 public yieldPerTokenStored;
    uint256 public lastUpdateTime;
    
    // Mock yield rate (annual percentage in basis points, e.g., 500 = 5%)
    uint256 public yieldRate = 500; // 5% APY
    
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed from, uint256 amount);
    event YieldClaimed(address indexed user, uint256 amount);
    event YieldGenerated(uint256 amount);
    event MaturityReached();
    
    modifier onlyYieldSplitter() {
        require(msg.sender == yieldSplitter, "Only yield splitter can call");
        _;
    }
    
    modifier onlyBeforeMaturity() {
        require(block.timestamp < maturity, "Token has matured");
        _;
    }
    
    modifier updateYield(address account) {
        _updateGlobalYield();
        if (account != address(0)) {
            _updateUserYield(account);
        }
        _;
    }
    
    constructor(
        string memory name,
        string memory symbol,
        address _underlyingAsset,
        uint256 _maturity
    ) ERC20(name, symbol) {
        underlyingAsset = _underlyingAsset;
        maturity = _maturity;
        isExpired = false;
        lastUpdateTime = block.timestamp;
    }
    
    /**
     * @notice Set the yield splitter contract address (only owner)
     * @param _yieldSplitter Address of the yield splitter contract
     */
    function setYieldSplitter(address _yieldSplitter) external onlyOwner {
        require(yieldSplitter == address(0), "Yield splitter already set");
        yieldSplitter = _yieldSplitter;
    }
    
    /**
     * @notice Set the principal token contract address (only owner)
     * @param _principalToken Address of the principal token contract
     */
    function setPrincipalToken(address _principalToken) external onlyOwner {
        require(principalToken == address(0), "Principal token already set");
        principalToken = _principalToken;
    }
    
    /**
     * @notice Set yield rate (only owner)
     * @param _yieldRate New yield rate in basis points
     */
    function setYieldRate(uint256 _yieldRate) external onlyOwner {
        require(_yieldRate <= 10000, "Yield rate too high"); // Max 100%
        yieldRate = _yieldRate;
    }
    
    /**
     * @notice Mint YT tokens (only yield splitter)
     * @param to Address to mint tokens to
     * @param amount Amount of tokens to mint
     */
    function mint(address to, uint256 amount) external onlyYieldSplitter onlyBeforeMaturity updateYield(to) {
        _mint(to, amount);
        lastClaimTime[to] = block.timestamp;
        emit Mint(to, amount);
    }
    
    /**
     * @notice Burn YT tokens (only yield splitter)
     * @param from Address to burn tokens from
     * @param amount Amount of tokens to burn
     */
    function burn(address from, uint256 amount) external onlyYieldSplitter updateYield(from) {
        // Claim any pending yield before burning
        _claimYield(from);
        _burn(from, amount);
        emit Burn(from, amount);
    }
    
    /**
     * @notice Claim accumulated yield for the caller
     * @return yieldAmount Amount of yield claimed
     */
    function claimYield() external nonReentrant updateYield(msg.sender) returns (uint256 yieldAmount) {
        return _claimYield(msg.sender);
    }
    
    /**
     * @notice Get claimable yield for a user
     * @param user Address to check yield for
     * @return yieldAmount Amount of yield claimable
     */
    function getClaimableYield(address user) external view returns (uint256 yieldAmount) {
        if (balanceOf(user) == 0) return 0;
        
        uint256 timeElapsed = block.timestamp - lastClaimTime[user];
        if (timeElapsed == 0) return accumulatedYield[user];
        
        // Calculate yield: (balance * yieldRate * timeElapsed) / (365 days * 10000)
        uint256 newYield = (balanceOf(user) * yieldRate * timeElapsed) / (365 days * 10000);
        return accumulatedYield[user] + newYield;
    }
    
    /**
     * @notice Check if token has reached maturity
     * @return bool True if current time >= maturity
     */
    function hasMatured() external view returns (bool) {
        return block.timestamp >= maturity;
    }
    
    /**
     * @notice Mark token as expired (can be called by anyone after maturity)
     */
    function markAsExpired() external {
        require(block.timestamp >= maturity, "Not yet matured");
        if (!isExpired) {
            isExpired = true;
            emit MaturityReached();
        }
    }
    
    /**
     * @notice Get time remaining until maturity
     * @return uint256 Seconds until maturity (0 if already matured)
     */
    function timeToMaturity() external view returns (uint256) {
        if (block.timestamp >= maturity) {
            return 0;
        }
        return maturity - block.timestamp;
    }
    
    /**
     * @notice Internal function to update global yield
     */
    function _updateGlobalYield() internal {
        if (totalSupply() == 0) {
            lastUpdateTime = block.timestamp;
            return;
        }
        
        uint256 timeElapsed = block.timestamp - lastUpdateTime;
        if (timeElapsed > 0) {
            uint256 yieldGenerated = (totalSupply() * yieldRate * timeElapsed) / (365 days * 10000);
            totalYieldGenerated += yieldGenerated;
            yieldPerTokenStored += (yieldGenerated * 1e18) / totalSupply();
            lastUpdateTime = block.timestamp;
            
            if (yieldGenerated > 0) {
                emit YieldGenerated(yieldGenerated);
            }
        }
    }
    
    /**
     * @notice Internal function to update user yield
     */
    function _updateUserYield(address user) internal {
        if (balanceOf(user) == 0) return;
        
        uint256 timeElapsed = block.timestamp - lastClaimTime[user];
        if (timeElapsed > 0) {
            uint256 newYield = (balanceOf(user) * yieldRate * timeElapsed) / (365 days * 10000);
            accumulatedYield[user] += newYield;
            lastClaimTime[user] = block.timestamp;
        }
    }
    
    /**
     * @notice Internal function to claim yield
     */
    function _claimYield(address user) internal returns (uint256 yieldAmount) {
        yieldAmount = accumulatedYield[user];
        if (yieldAmount > 0) {
            accumulatedYield[user] = 0;
            totalYieldClaimed += yieldAmount;
            
            // In a real implementation, this would transfer the underlying asset
            // For now, we'll emit an event and the yield splitter will handle the transfer
            emit YieldClaimed(user, yieldAmount);
        }
    }
    
    /**
     * @notice Override transfer to update yield for both sender and receiver
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override updateYield(from) updateYield(to) {
        super._beforeTokenTransfer(from, to, amount);
    }
}
